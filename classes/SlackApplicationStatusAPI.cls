@RestResource(urlMapping='/application-status/*')
global class SlackApplicationStatusAPI {
 
    @HttpPost
    global static void handleApplicationStatus() {
        RestRequest req = RestContext.request;
        RestResponse res = RestContext.response;
        String responseText;
        // Extract the last part of the URL after '/application-status/'
        String path = req.requestURI;
        String statusFilter = '';
        if (path != null && path.contains('/application-status/')) {
            statusFilter = path.split('/application-status/')[1];
        }
        System.debug('üåü Extracted statusFilter: ' + statusFilter);
 
        try {
            List<Received_Application__c> applications;
            String userFriendlyStatus = '';
 
            // Define the queries for different statuses
            if (statusFilter == 'approved') {
                applications = [
                    SELECT Name, Applicant_s_Name__c, Credit_Score__c, 
                           Applicant_s_Income__c, Email__c, Phone__c, Final_Verification__c
                    FROM Received_Application__c 
                    WHERE Status__c = 'Approved'
                ];
                userFriendlyStatus = '‚úÖ Approved Applications';
            }
            else if (statusFilter == 'notapproved') {
                applications = [
                    SELECT Name, Applicant_s_Name__c, Credit_Score__c, 
                           Applicant_s_Income__c, Email__c, Phone__c, Final_Verification__c
                    FROM Received_Application__c 
                    WHERE Status__c = 'Not Approved'
                ];
                userFriendlyStatus = '‚ùå Not Approved Applications';
            }
            else if (statusFilter == 'manualreview') {
                applications = [
                    SELECT Name, Applicant_s_Name__c, Credit_Score__c, 
                           Applicant_s_Income__c, Email__c, Phone__c, Final_Verification__c
                    FROM Received_Application__c 
                    WHERE Status__c = 'Manual Review'
                ];
                userFriendlyStatus = 'üõ†Ô∏è Manual Review Applications';
            }
            else {
                responseText = '‚ö†Ô∏è Invalid request. Please specify a valid application status (approved, notapproved, manualreview).';
                sendResponse(responseText);
                return;
            }
 
            System.debug('‚ö° Query result count: ' + applications.size());
 
            if (applications.isEmpty()) {
                responseText = 'üö´ No ' + userFriendlyStatus + ' found.';
            } else {
                responseText = 'üìã *' + userFriendlyStatus + '*:\n\n';
                for (Received_Application__c app : applications) {
                    responseText += 'üîπ *Application ID:* ' + app.Name + '\n';
                    responseText += 'üë§ *Applicant Name:* ' + app.Applicant_s_Name__c + '\n';
                    responseText += 'üìà *Credit Score:* ' + String.valueOf(app.Credit_Score__c) + '\n';
                    responseText += 'üíµ *Applicant Income:* ‚Çπ' + String.valueOf(app.Applicant_s_Income__c) + '\n';
                    responseText += '‚úâÔ∏è *Email:* ' + app.Email__c + '\n';
                    responseText += 'üìû *Phone:* ' + app.Phone__c + '\n';
                    responseText += 'üîç *Final Verification:* ' + String.valueOf(app.Final_Verification__c) + '\n';
                    responseText += '----------------------------------\n';
                }
            }
        } catch (Exception e) {
            System.debug('‚ùå Error during query execution: ' + e.getMessage());
            responseText = '‚ö†Ô∏è An error occurred while fetching applications. Please try again later.';
        }
 
        sendResponse(responseText);
    }
 
    private static void sendResponse(String responseText) {
        RestResponse res = RestContext.response;
        Map<String, Object> jsonResponse = new Map<String, Object> {
            'response_type' => 'ephemeral',  // Show to the user who invoked it
            'text' => responseText
        };
        res.responseBody = Blob.valueOf(JSON.serialize(jsonResponse));
        res.statusCode = 200;
        res.addHeader('Content-Type', 'application/json');
    }
}